//----------------------------------------------------------------------------------
// [ 보행자 천국 ] https://programmers.co.kr/learn/courses/30/lessons/1832
//
// 1. 왼쪽에서 오른쪽, 위에서 아래로 맵을 탐색하면서 교차로마다 가능한 경우를 누적한다
//   1-1. 현재 자동차의 방향에 따라 경우를 각자 누적한다: 우측(dp[i][j][0]), 아래(dp[i][j][1])
//   1-2. 이전 교차로에서 좌측에서 오는 경우, 위에서 오는 경우를 합한다: 좌측(dp[i][j-1]), 위(dp[i-1][j])
//   1-3. 1-2의 경우 이전 교차로가 회전금지(2)일 경우 자동차 방향이 다른 경우는 무시한다 
//        (ex: 좌측 교차로가 회전금지일 때 우측 방향의 차량의 경우만 통과)
//   1-4. 탐색중인 교차로가 통행금지(1)일 경우 무시한다
// 2. 1의 결과 dp 배열 끝에 위치한 값이 정답이다
//----------------------------------------------------------------------------------

#include <vector>
using namespace std;
const int MOD = 20170805;

int solution(int h, int w, vector<vector<int>> map) {
    int dp[500][500][2] = {{1}};
    
    for (int i = 0; i < h; ++i) {
        for (int j = 0; j < w; ++j) {
            if (map[i][j] == 1) continue;

            if (i > 0) {
                if (map[i-1][j] != 2) dp[i][j][1] += dp[i-1][j][0];
                dp[i][j][1] += dp[i-1][j][1];
            }
            if (j > 0) {
                if (map[i][j-1] != 2) dp[i][j][0] += dp[i][j-1][1];
                dp[i][j][0] += dp[i][j-1][0];
            }
            dp[i][j][0] %= MOD; dp[i][j][1] %= MOD;
        }
    }

    return (dp[h-1][w-1][0] + dp[h-1][w-1][1]) % MOD;
}